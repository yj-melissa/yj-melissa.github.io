---
title: "[Python] 백준 11780. 플로이드2"
date: 2024-05-27 22:20:04 +0900
categories:
  - algorithm
tags:
  - Python
---
# [Gold II] 플로이드 2 - 11780 

[문제 링크](https://www.acmicpc.net/problem/11780) 

### 성능 요약

메모리: 33164 KB, 시간: 4636 ms

### 분류

플로이드–워셜, 그래프 이론, 최단 경로

### 제출 일자

2024년 5월 27일 22:11:33

### 문제 설명

<p>n(1 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.</p>

<p>모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.</p>

### 출력 

 <p>먼저, n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.</p>

<p>그 다음에는 n×n개의 줄을 출력해야 한다. i×n+j번째 줄에는 도시 i에서 도시 j로 가는 최소 비용에 포함되어 있는 도시의 개수 k를 출력한다. 그 다음, 도시 i에서 도시 j로 가는 경로를 공백으로 구분해 출력한다. 이때, 도시 i와 도시 j도 출력해야 한다. 만약, i에서 j로 갈 수 없는 경우에는 0을 출력한다.</p>

<br>

# 코드
```python
INF = int(1e9)  
  
n = int(input())        # 도시 개수  
m = int(input())        # 버스 개수  
graph = [[INF] * (n + 1) for _ in range(n + 1)]  
path = [[list()] * (n + 1) for _ in range(n + 1)]         # 경로 저장  
  
  
for i in range(1, n + 1):  
    graph[i][i] = 0     # 자기 자신으로 가는 비용은 0  
for _ in range(m):      # 버스 정보 입력  
    a, b, c = map(int, input().split())  
    if c < graph[a][b]:  
        graph[a][b] = c  
        path[a][b] = [a, b]  
  
for k in range(1, n + 1):  
    for i in range(1, n + 1):  
        for j in range(1, n + 1):  
            new_cost = graph[i][k] + graph[k][j]  
            if new_cost < graph[i][j]:  
                graph[i][j] = new_cost  
                path[i][j] = path[i][k][:-1] + path[k][j]  
  
for i in range(1, n + 1):               # 최소 비용 출력  
    for j in range(1, n + 1):  
        if graph[i][j] == INF:  
            graph[i][j] = 0  
        print(graph[i][j], end = ' ')  
    print()  
  
for i in range(1, n + 1):  
    for j in range(1, n + 1):  
        if len(path[i][j]) == 0:  
            print(0)  
        else:  
            print(len(path[i][j]), end = ' ')  
            for p in path[i][j]:  
                print(p, end = ' ')  
            print()
```

<br>

# 푼 방법
바로 앞에서 푼 11404와 비슷한 문제. 다만 이제 경로까지 저장했다가 출력해야 한다. 내가 선택한 방법은 경로를 배열에 저장하는 것. 3차원 배열ㅎㅎ이 되어버렸고, 코드도 얕은 복사를 피하기 위해 `[[list()] * (n + 1) for _ in range(n + 1)]`라는 모습으로 만들고 말았다. 다른 변수로 만들고 for문으로 추가할까 생각도 했지만 일단은 이렇게.
<br>
기본 플로이드 워셜 알고리즘을 그대로 사용했고, 경로 저장하는 코드들과 그 경로를 출력하는 코드들만 추가했다. 인덱스 에러를 피하기 위해 시작점과 도착점을 모두 넣어 사용했고.
<br>

알고리즘은 어느 정도 체념해야 하지만 코드가 깔끔하지 않아 매우 불만족스럽다.

<br>
# 알아둘 점
다른 사람들의 코드를 보니 경로에 시작점만 저장해둔 후 경로 출력 때 역추적 하는 방법이 있었다. 다음에는 사용해보기.