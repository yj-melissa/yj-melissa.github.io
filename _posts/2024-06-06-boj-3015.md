---
title: "[Python] 백준 3015. 오아시스 재결합"
date: 2024-06-07 00:56:13 +0900
categories:
  - algorithm
tags:
  - Python
  - ★
---
# [Platinum V] 오아시스 재결합 - 3015 

[문제 링크](https://www.acmicpc.net/problem/3015) 

### 성능 요약

메모리: 50548 KB, 시간: 532 ms

### 문제 설명

<p>
	오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.</p>

<p>
	이 역사적인 순간을 맞이하기 위해 줄에서서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해 졌다.</p>

<p>
	두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.</p>

<p>
	줄에 서있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>
	첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)</p>

<p>
	둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 2<sup>31</sup> 나노미터 보다 작다.</p>

<p>
	사람들이 서 있는 순서대로 입력이 주어진다.</p>

### 출력 

 <p>
	서로 볼 수 있는 쌍의 수를 출력한다.</p>

<br>
### 코드
```python
import sys
input = sys.stdin.readline

N = int(input())
heights = [int(input()) for _ in range(N)]
stack = []
answer = 0

for i in range(N):
    cnt = 1

    while stack and stack[-1][0] <= heights[i]:
        h, c = stack.pop()
        answer += c

        if h == heights[i]:     # 키가 같은 경우
            cnt += c

    if stack:
        answer += 1

    stack.append((heights[i], cnt))

print(answer)
```

<br>
### 설명
`cnt`는 현재 `i`번째 사람이 등장한 횟수다. 기존 스택에는 (키, 등장횟수) 형태로 정보가 들어있다. 만일 스택 맨 위 사람 키가 현재 사람보다 작거나 크다면 스택에서 제거하고, 현재까지 등장횟수`c`를 `answer`에 추가해준다.
이 문제에서는 키가 같은 경우도 서로 볼 수 있다고 허용하고 있으므로, 만일 키가 같은 사람이 나란히 서있는 경우(ex. [2, 2, 2, 3])를 고려해 등장 횟수를 저장해두는 것. 
![image](https://github.com/yj-melissa/yj-melissa.github.io/assets/109330621/cbbc5142-3b15-484b-9a64-0584e7ca3df2)
[2, 2, 2, 3]의 경우 `cnt`가 점차 1, 2, 3으로 커지면서 `answer`에도 똑같이 반영되는데 이를 통해 전체 쌍이 반영되는 것. 이래서 등장 횟수를 체크하는구나 하면서도 사실 제대로 이해한 게 맞나 의심스럽기는 하다. 
만일 스택에 사람이 포함되어 있으면 현재 사람과 바로 앞의 사람은 서로 볼 수 있으므로 `answer`에 1을 더해준다.

<br>
<br>

이 문제를 처음에 봤을 때는 단순한 스택 문제 같은데 왜 난이도가 플레5씩이나 되나 싶었다. 풀어보니 알겠다.. 가장 큰 문제는 키가 같은 사람도 허용해주고, '쌍'을 구해야한다는 점 같다.

처음에는 손으로 예제를 풀었을 때 서로 앞뒤인 경우는 무조건 서로 볼 수 있는 쌍이니 `answer = N - 1`로 풀고, 스택에서 `pop()`을 할 때마다 `answer`를 1씩 늘려주는 방식을 택해봤는데 답은 나오지 않았다. 가급적 스택에 키만 넣은 상태로 문제를 풀어보고 싶었는데 진짜 불가능한가..